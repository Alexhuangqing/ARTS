## binlog基本知识

原文出处：https://www.cnblogs.com/rjzheng/p/9721765.html

介绍维度：

1. binlog的相关概念

2. 怎么解析binlog

   - 一个定义,两个误解,三个用途,四个常识 

   1. 一个定义
      > binlog是记录所有数据库表结构变更（例如CREATE、ALTER TABLE…）以及表数据修改（INSERT、UPDATE、DELETE…）的二进制日志。
      >
      > 多说一句，如果`update`操作没有造成数据变化，也是会记入`binlog`。

      > binlog不会记录SELECT和SHOW这类操作，因为这类操作对数据本身并没有修改，但你可以通过查询通用日志来查看MySQL执行过的所有语句。  

   2. 两个误解

      - **binlog只是一类记录操作内容的日志文件** 

        binlog包含两类文件：

        1. 索引文件（文件名后缀为.index）用于记录哪些日志文件正在被使用

        2. 日志文件（文件名后缀为.00000*）记录数据库所有的DDL和DML(除了数据查询语句)语句事件。

           ```log_bin：on 打开binlog日志  log_bin_basename：bin文件路径及名前缀（/var/log/mysql/mysql-bin）  log_bin_index：bin文件index（/var/log/mysql/mysql-bin.index）
           log_bin：on 打开binlog日志
           
           log_bin_basename：bin文件路径及名前缀（/var/log/mysql/mysql-bin）
           
           log_bin_index：bin文件index（/var/log/mysql/mysql-bin.index）
           ```

           

           日志文件参数：

           ​	`innodb`里其实又可以分为两部分，一部分在缓存中，一部分在磁盘上。这里业内有一个词叫做**刷盘**，就是指将缓存中的日志刷到磁盘上。跟**刷盘**有关的参数有两个:`sync_binlog`和`binlog_cache_size`

           ​	 

           - (1)`binlog_cache_size`设过大，会造成内存浪费。`binlog_cache_size`设置过小，会频繁将缓冲日志写入临时文件。具体怎么设，有兴趣自行查询，我觉得研发大大根本没机会去设这个值的，了解即可。
           - (2)`sync_binlog=0`:表示刷新`binlog`时间点由操作系统自身来决定，操作系统自身会每隔一段时间就会刷新缓存数据到磁盘，这个性能最好。`sync_binlog=1`，代表每次事务提交时就会刷新binlog到磁盘。`sync_binlog=N`,代表每N个事务提交会进行一次binlog刷新。

      - **binlog是InnoDb独有的** 

        ​	`binlog`是以事件形式记录的，这句话通俗点说，就是`binlog`的内容都是一个个的事件。这块具体的我会在下一篇讲，这篇记住`binlog`的内容就是一个个事件就行。 注意了，这里的用词，是一个个事件，而不是事务。大家应该知道`Innodb`和`mysiam`最显著的区别就是一个支持事务，一个不支持事务。 因此你可以说，`binlog`是基于事务来记录二进制日志，比如`sync_binlog=1`,每提交一次事务，就写入`binlog`。你却不能说`binlog`是事务日志，`binlog`不仅记录`innodb`日志，在`myisam`中，也一样存在`binlog`。 

   3. 三个用途

      这三个用途，出自《MySQL技术内幕 InnoDB存储引擎》一书，分别为**恢复**、**复制**、**审计**。这三个用途，研发大大们了解一下即可，比如数据恢复，你碰到同事删库的机会实在太少。假如真的有同事舍己为人，冒着离职的风险给你提供做数据**恢复**的机会，大把运维工程师待命在那，轮不到你的。所以，这三个功能了解即可。

      **恢复**：这里网上有大把的文章指导你，如何利用`binlog`日志恢复数据库数据。如果你真的觉得自己很有时间，就自己去创建个库，然后删了，再去恢复一下数据，练练手吧。

      **复制**: 如图所示（图片不是自己画的，偷懒了）

      ![image](https://www.cnblogs.com/images/cnblogs_com/rjzheng/1281019/o_youhua1.jpg)
      **主库有一个`log dump`线程**，将`binlog`传给从库
      **从库有两个线程**，一个I/O线程，一个SQL线程，I/O线程读取主库传过来的`binlog`内容并写入到`relay log`,SQL线程从`relay log`里面读取内容，写入从库的数据库。

      **审计**：用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入攻击。

   4. 四个常识

      这块知识我用一个表格来表示，没必要啰嗦一大堆。

      | format    | 定义                       | 优点                           | 缺点                                                         |
      | --------- | -------------------------- | ------------------------------ | ------------------------------------------------------------ |
      | statement | 记录的是修改SQL语句        | 日志文件小，节约IO，提高性能   | 准确性差，对一些系统函数不能准确复制或不能复制，如now()、uuid()等 |
      | row       | 记录的是每行实际数据的变更 | 准确性强，能准确复制数据的变更 | 日志文件大，较大的网络IO和磁盘IO                             |
      | mixed     | statement和row模式的混合   | 准确性强，文件大小适中         | 有可能发生主从不一致问题                                     |

      业内目前推荐使用的是`row`模式，准确性高，虽然说文件大，但是现在有SSD和万兆光纤网络，这些磁盘IO和网络IO都是可以接受的。
      那么，大家一定想问，为什么不推荐使用`mixed`模式，理由如下
      假设master有两条记录，而slave只有一条记录。
      master的数据为

      ```
      +----+------------------------------------------------------+
      | id | n |
      +----+------------------------------------------------------+
      | 1 | d24c2c7e-430b-11e7-bf1b-00155d016710 |
      | 2 | ddd |
      +----+------------------------------------------------------+
      ```

      slave的数据为

      ```
      +----+-------------------------------------------------------+
      | id | n |
      +----+-------------------------------------------------------+
      | 1 | d24c2c7e-430b-11e7-bf1b-00155d016710 |
      +----+-------------------------------------------------------+
      ```

      当在`master`上更新一条从库不存在的记录时，也就是`id=2`的记录，你会发现`master`是可以执行成功的。而`slave`拿到这个SQL后，也会照常执行，不报任何异常，只是更新操作不影响行数而已。并且你执行命令`show slave status`，查看输出，你会发现没有异常。但是，如果你是`row`模式，由于这行根本不存在，是会报1062错误的。

      **常识二:怎查看binlog**
      `binlog`本身是一类二进制文件。二进制文件更省空间，写入速度更快，是无法直接打开来查看的。
      因此mysql提供了命令`mysqlbinlog`进行查看。
      一般的`statement`格式的二进制文件，用下面命令就可以

      ```
      mysqlbinlog mysql-bin.000001 
      ```

      如果是`row`格式，加上`-v`或者`-vv`参数就行，如

      ```
      mysqlbinlog -vv mysql-bin.000001 
      ```

      **常识三:怎么删binlog**
      删`binlog`的方法很多，有三种是常见的

      (1) 使用`reset master`,该命令将会删除所有日志，并让日志文件重新从000001开始。

      (2) 使用命令

      ```
      PURGE { BINARY | MASTER } LOGS { TO 'log_name' | BEFORE datetime_expr }
      ```

      例如

      ```
      purge master logs to "binlog_name.00000X" 
      ```

      将会清空00000X之前的所有日志文件.

      (3) 使用`--expire_logs_days=N`选项指定过了多少天日志自动过期清空。

      **常识四:binlog常见参数**
      常见参数，列举如下，有个印象就好。

      | 参数名                                        | 含义                                           |
      | --------------------------------------------- | ---------------------------------------------- |
      | log_bin = {on \| off \| base_name}            | 指定是否启用记录二进制日志或者指定一个日志路径 |
      | sql_log_bin ={ on \| off }                    | 指定是否启用记录二进制日志                     |
      | expire_logs_days                              | 指定自动删除二进制日志的时间，即日志过期时间   |
      | log_bin_index                                 | 指定mysql-bin.index文件的路径                  |
      | binlog_format = { mixed \| row \| statement } | 指定二进制日志基于什么模式记录                 |
      | max_binlog_size                               | 指定二进制日志文件最大值                       |
      | binlog_cache_size                             | 指定事务日志缓存区大小                         |
      | max_binlog_cache_size                         | 指定二进制日志缓存最大大小                     |
      | sync_binlog = { 0 \| n }                      | 指定写缓冲多少次，刷一次盘                     |

       

   